# inject-golang
Provide container of DI(Dependency Injection) for golang.

Language: English [中文](README_cn.md) 

### 1. Install and Run

```shell
go install github.com/ellisez/inject-golang
```
### 1.1. use go generate
```go
package main

import (
	"github.com/ellisez/inject-golang/examples/ctx"
)

//go:generate inject-golang
func main() {
	ctx.New()
}
```
> //go:generate inject-golang

### 1.2. Run
```shell
go generate -run inject-golang
```
## 2. Annotates
### 2.1. Struct Annotate
```
// @provide <Instance，default structName> <singleton default|multiple>
// @import *<Path, required> <Alias>
// @injectField *<FieldName, required> <Instance，default structName>
// @preConstruct *<before create call func, required>
// @postConstruct *<after created call func, required>
```

### 2.2. Field Annotate in struct
```
// @inject <Instance，default fieldName>
```
### 2.3. Func Annotate (use for all func)
```
// @proxy <Instance，default funcName>
// @import *<Path, required> <Alias>
// @injectParam *<ParamName, required> <Instance，default paramName>
// @injectRecv *<ParamName, required> <Instance，default paramName>
```

### 2.4. WebApp Annotate (web server provided)
```
// @webApp <WebApp，default WebApp>
// @static *<Path, required> *<Dirname, required> [Features: Compress|Download|Browse] <Index> <MaxAge>
```

### 2.5. Router Annotate (like swag)
```
// @route *<Path, required> [Method: get|post]
// @param *<ParamName, required> <type:query|path|header|body|formData> <DataType> <IsRequired> <Description>
```

### 2.6. Middleware Annotate
```
// @middleware <Path>
// @param *<ParamName, required> <type:query|path|header|body|formData> <DataType> <IsRequired> <Description>
```

>
> `@preConstruct` is usually used to set default values. 
> Unable to get Ctx, because it is not yet ready. 
> If you want to run with Ctx, you can use PostConstruct;
>
> `@proxy`are used to mark the parameters of a function for dependency injection, which ultimately generates an ctx container internal method with the same name as the original function;
> Access the function with the same name through ctx during use;
>
> FuncName of `@preConstruct` and `@postConstruct`, with package like `@postConstruct model.Database` only work at `@import` Path, But without package can use the func generated by ctx.
>
> It is recommended to use the '@ postConstruct' annotation to point to a '@ proxy' proxy function instead of directly pointing to the original function, which can allow the original function to receive parameter injection;
>
> `Ctx ` is a system reserved instance that represents the context container itself and is suitable for annotations such as @ inject @ injectParam @ injectField;


## 3. Generated code

### 3.1. PreConstruct & PostConstruct
Original structure
```go
// WebApp
// @provide WebCtxAlias
// @injectField Database
// @preConstruct model.PrepareWebCtxAlias
// @postConstruct model.WebCtxAliasLoaded
type WebApp struct {
	// @inject
	*Config
	*Database
	MiddleWares []*MiddleWare
	Routers     []*Router
}
```
preConstruct function, Requirement must be no parameter and return type must be the same as the original struct.
```go
func PrepareWebCtxAlias() *WebApp {
    return &WebApp{}
}
```
postConstruct function, Requirement the parameter must be of the original structure type.
```go
func WebCtxAliasLoaded(webApp *WebApp) {
	
}
```

### 3.2. Proxy Function

Original Function
```go
// WebCtxAliasLoaded
// @proxy
// @injectParam database Database
// @injectParam ctx
func WebCtxAliasLoaded(ctx *ctx.Ctx/*Special inject*/, webApp *WebApp/*uninjected*/, database *Database/*param inject*/) {
	fmt.Printf("WebCtxAliasLoaded: %v\n%v\n", webApp, database)
	ctx.TestLogin(webApp)
}
```
Generated Function
```go
func (ctx *Ctx/*Same name function in Ctx*/) WebCtxAliasLoaded(WebApp *model.WebApp/*Keep uninjected*/) {
	model.WebCtxAliasLoaded(ctx/*Special inject*/, WebApp, ctx.Database/*param inject*/)
}
```

> Since the postConstruct function must receive a parameter that is the same as the annotated structure, 
> and the proxy proxy function retains the uninjected parameter in the generated function, 
> we recommend that postConstruct directly proxy the generated function instead of directly pointing to the original function.
> 
> Using the original function to retain uninjected structural parameters to facilitate the generated function to meet the requirements of postConstruct.

### 3.3. Generated Directory
```
/ctx
    |- gen_ctx.go
        --------------------------------
        # gen segment: Struct #
        --------------------------------
        type Ctx struct {
            {{range SingletonInstances}}
            Instance Name
            {{end}}
        }
      
        -----------------------------------
        # gen segment: Singleton instance #
        -----------------------------------
        func New() *Ctx {
            ctx := &Ctx{}
            {{range SingletonInstances}}
                {{if PreConstruct}}
                    ctx.{{Instance}} := {{PreConstruct}}()
                {{else}}
                    ctx.{{Instance}} = &{{Package}}.{{Name}}{}
                {{end}}
            {{end}}
            
            {{range SingletonInstances}}
                {{range InjectFields}}
                    {{if FieldInstance == "Ctx"}}
                    ctx.{{Instance}}.{{FieldInstance}} = ctx
                    {{else}}
                    ctx.{{Instance}}.{{FieldInstance}} = ctx.{{StructInstance}}
                    {{end}}
                {{end}}
            {{end}}
            
            {{range SingletonInstances}}
                {{if PostConstruct}}
                    {{PostConstruct}}(
                        ctx.{{Instance}},
                    )
                {{end}}
            {{end}}
            return ctx
        }
    |- gen_constructor.go
        ------------------------------------
        # gen segment: Multiple instance #
        ------------------------------------
        {{range MultipleInstances}}
            func (ctx *Ctx) New{{Instance}}(
                {{range NormalFields}}
                {{FieldInstance}} {{FieldType}},
                {{end}}
            ) *{{Type}} {
                {{if PreConstruct}}
                    {{Instance}} := {{PreConstruct}}()
                {{else}}
                    {{Instance}} := &{{Package}}.{{Name}}{}
                {{end}}
                {{range Fields}}
                    {{if IsInject}}
                        {{if FieldInstance == "Ctx"}}
                        {{Instance}}.{{FieldName}} = ctx
                        {{else}}
                        {{Instance}}.{{FieldName}} = ctx.{{FieldInstance}}
                        {{end}}
                    {{else}}
                        {{Instance}}.{{FieldName}} = {{FieldInstance}}
                    {{end}}
                {{end}}
                
                {{if PostConstruct}}
                    {{PostConstruct}}(
                        {{Instance}},
                    )
                {{end}}
                return {{Instance}}
            }
        {{end}}
        
    |- gen_func.go
        ------------------------------------
        # gen segment: Func inject #
        ------------------------------------
        {{range FuncInstances}}
            func (ctx *Ctx) {{Proxy}}(
                {{range NormalParams}}
                {{ParamInstance}} {{ParamType}},
                {{end}}
            ) (
                {{range Results}}
                {{ResultName}} {{ResultType}},
                {{end}}
            ) {
                return {{Package}}.{{FuncName}}(
                    {{range Params}}
                        {{if IsInject}}
                            {{if ParamInstance == "Ctx"}}
                            ctx,
                            {{else}}
                            ctx.{{ParamInstance}},
                            {{end}}
                        {{else}}
                            {{ParamInstance}},
                        {{end}}
                    {{end}}
                )
            }
        {{end}}
        
    |- gen_method.go
        ------------------------------------
        # gen segment: Method inject #
        ------------------------------------
        func (ctx *Containe) {{Proxy}}(
            {{if !Recv.IsInject}}
            {{Recv.Name}} {{Recv.Type}},
            {{end}}
            {{range NormalParams}}
            {{ParamInstance}} {{ParamType}},
            {{end}}
        ) (
            {{range Results}}
            {{ResultName}} {{ResultType}},
            {{end}}
        ) {
            return {{Recv.Name}}.{{FuncName}}(
                {{if !Recv.IsInject}}
                {{Recv.Name}},
                {{end}}
                {{range Params}}
                    {{if IsInject}}
                        {{if ParamInstance == "Ctx"}}
                        ctx,
                        {{else}}
                        ctx.{{ParamInstance}},
                        {{end}}
                    {{else}}
                        {{ParamInstance}},
                    {{end}}
                {{end}}
            )
        }
```
