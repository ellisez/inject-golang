package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"os"
	"path/filepath"
)

// gen_func.go
func genFuncFile(ctx *model.Ctx, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenFuncFilename)

	if ctx.FuncInstance.FuncLen() == 0 {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	astFile := &ast.File{
		Name:  ast.NewIdent(GenInternalPackage),
		Scope: ast.NewScope(nil),
	}

	genFuncImportsAst(ctx, astFile, filename)

	genFuncAst(ctx, astFile)

	return utils.GenerateCode(filename, astFile, ctx,
		`// Code generated by "inject-golang -m func"; DO NOT EDIT.`)
}
func genFuncImportsAst(ctx *model.Ctx, astFile *ast.File, filename string) {

	for i := 0; i < ctx.FuncInstance.Len(); i++ {
		instance := ctx.FuncInstance.IndexOf(i)
		if instance.Recv == nil {
			for _, importInfo := range instance.Imports {
				importName := importInfo.Alias
				if importName == "_" {
					importName = ""
				}
				err := addImport(astFile, ctx, importName, importInfo.Path)
				if err != nil {
					if err != nil {
						utils.Failuref("%s, %s", filename, err.Error())
					}
				}
			}
		}
	}
}

// # gen segment: Func inject #
func genFuncAst(ctx *model.Ctx, astFile *ast.File) {
	ctxVar := utils.FirstToLower(CtxType)

	for i := 0; i < ctx.FuncInstance.Len(); i++ {
		instance := ctx.FuncInstance.IndexOf(i)
		if instance.Recv == nil {

			var stmts []ast.Stmt
			instanceCallExpr, varDefineStmts := astInstanceCallExpr(astSelectorExpr(instance.Package, instance.FuncName), instance.Func, ctx, ctxVar)
			if varDefineStmts != nil {
				stmts = append(stmts, varDefineStmts...)
			}
			if len(instance.Results) == 0 {
				stmts = append(stmts, &ast.ExprStmt{
					X: instanceCallExpr,
				})
			} else {
				stmts = append(stmts, &ast.ReturnStmt{
					Results: []ast.Expr{
						instanceCallExpr,
					},
				})
			}

			// [code] func (ctx *Container) {{Proxy}}(
			funcDecl := astInstanceProxyFunc(instance.Func, instance.Instance)
			funcDecl.Body = &ast.BlockStmt{
				List: stmts,
			}
			funcDecl.Doc = &ast.CommentGroup{List: []*ast.Comment{{
				Text: fmt.Sprintf("// Generate by annotations from %s.%s", ImportAliasMap[instance.Package].Path, instance.FuncName),
			}}}
			addDecl(astFile, funcDecl)
			ctx.Methods[funcDecl.Name.String()] = funcDecl
		}
	}

}
