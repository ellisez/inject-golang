package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"os"
	"path/filepath"
)

// gen_func.go
func genFuncFile(ctx *model.Ctx, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenFuncFilename)

	if ctx.FuncInstances == nil {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	astFile := &ast.File{
		Name:  ast.NewIdent(GenInternalPackage),
		Scope: ast.NewScope(nil),
	}

	genFuncImportsAst(ctx, astFile)

	genFuncAst(ctx, astFile)

	astFile, err := utils.OptimizeCode(filename, astFile, ctx,
		`// Code generated by "inject-golang -m func"; DO NOT EDIT.`)
	if err != nil {
		return err
	}

	return utils.GenerateCode(filename, astFile, ctx)
}
func genFuncImportsAst(ctx *model.Ctx, astFile *ast.File) {

	for _, instance := range ctx.FuncInstances {
		for _, importInfo := range instance.Imports {
			importName := importInfo.Name
			if importName == "_" {
				importName = ""
			}
			addImport(astFile, ctx, importName, importInfo.Path)
		}
	}
}

// # gen segment: Func inject #
func genFuncAst(ctx *model.Ctx, astFile *ast.File) {
	ctxVar := utils.FirstToLower(CtxType)

	for _, instance := range ctx.FuncInstances {
		params := make([]*ast.Field, 0)
		for _, paramInfo := range instance.Params {
			if paramInfo.Source == "" {
				// [code] {{ParamInstance}} {{ParamType}},
				paramInstance := paramInfo.Instance
				if paramInstance == "" {
					paramInstance = paramInfo.Name
					if paramInfo.Name == "" {
						paramInstance = utils.TypeShortName(paramInfo.Type)
					}
				}
				params = append(params,
					astField(paramInstance,
						utils.AccessType(
							paramInfo.Type,
							instance.Package,
							GenPackage,
						),
					),
				)
			}
		}

		stmts := make([]ast.Stmt, 0)

		instanceCallExpr := astInstanceCallExpr(astSelectorExpr(instance.Package, instance.FuncName), instance.Func, ctx, ctxVar)
		if len(instance.Results) == 0 {
			stmts = append(stmts, &ast.ExprStmt{
				X: instanceCallExpr,
			})
		} else {
			stmts = append(stmts, &ast.ReturnStmt{
				Results: []ast.Expr{
					instanceCallExpr,
				},
			})
		}

		var results []*ast.Field
		for _, result := range instance.Results {
			results = append(results, astField(result.Name, result.Type))
		}

		// [code] func (ctx *Container) {{Proxy}}(
		funcDecl := astInstanceProxyFunc(instance.Func, instance.Instance)
		funcDecl.Body = &ast.BlockStmt{
			List: stmts,
		}
		genDoc := &ast.Comment{
			Text: fmt.Sprintf("// Generate by annotations from %s.%s", instance.Package, instance.FuncName),
		}
		funcDecl.Doc = &ast.CommentGroup{List: []*ast.Comment{
			{
				Text: fmt.Sprintf("\n// %s", instance.Instance),
			},
			genDoc,
		}}
		addDecl(astFile, funcDecl)
		ctx.Methods = append(ctx.Methods, funcDecl)
	}

}
