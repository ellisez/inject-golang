package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"os"
	"path/filepath"
	"strings"
)

// gen_multiple.go
func genMultipleFile(ctx *model.Ctx, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenMultipleFilename)

	if ctx.MultipleInstances == nil {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	astFile := &ast.File{
		Name:  ast.NewIdent(GenInternalPackage),
		Scope: ast.NewScope(nil),
	}

	genMultipleImportsAst(ctx, astFile)

	genMultipleNewAst(ctx, astFile)

	astFile, err := utils.OptimizeCode(filename, astFile, ctx,
		`// Code generated by "inject-golang -m multiple"; DO NOT EDIT.`)
	if err != nil {
		return err
	}

	return utils.GenerateCode(filename, astFile, ctx)
}

func genMultipleImportsAst(ctx *model.Ctx, astFile *ast.File) {

	for _, instance := range ctx.MultipleInstances {
		for _, importInfo := range instance.GetImports() {
			importName := importInfo.Name
			if importName == "_" {
				importName = ""
			}
			addImport(astFile, ctx, importName, importInfo.Path)
		}
	}
}

// # gen segment: Multiple instance #
func genMultipleNewAst(ctx *model.Ctx, astFile *ast.File) {
	ctxVar := utils.FirstToLower(CtxType)

	for _, instance := range ctx.MultipleInstances {
		instanceName := instance.GetInstance()
		instanceType := instance.GetType()
		instanceFunc := instance.GetFunc()
		handler := instance.GetHandler()

		instanceVar := utils.FirstToLower(instanceName)

		var stmts []ast.Stmt

		// [code] {{Provide}} := &{{Package}}.{{Name}}{}
		stmts = append(stmts, astDefineStmt(
			ast.NewIdent(instanceVar),
			astDeclareRef(instanceType, nil),
		))

		if handler != "" {

			var instanceCallExpr *ast.CallExpr
			if strings.Contains(handler, ".") {
				// [code] {{Handler}}(ctx.{{}})
				instanceCallExpr = &ast.CallExpr{
					Fun:  ast.NewIdent(handler),
					Args: []ast.Expr{ast.NewIdent(instanceVar)},
				}
			} else {
				// [code] ctx.{{Handler}}(ctx.{{}})
				instanceCallExpr = &ast.CallExpr{
					Fun:  astSelectorExpr(ctxVar, handler),
					Args: []ast.Expr{ast.NewIdent(instanceVar)},
				}
			}

			// [code] {{Package}}.{{FunName}}(...)
			stmts = append(stmts, &ast.ExprStmt{
				X: instanceCallExpr,
			})
		}

		// [code] return {{Provide}}
		stmts = append(stmts, &ast.ReturnStmt{
			Results: []ast.Expr{
				ast.NewIdent(instanceVar),
			},
		})

		// [code] func (ctx *Ctx) New{{Provide}}(
		constructor := "New" + instanceName

		resultType := instanceType
		funcDecl := astFuncDecl(
			[]*ast.Field{
				astField(ctxVar, astStarExpr(ast.NewIdent(CtxType))),
			},
			constructor,
			nil,
			[]*ast.Field{
				{
					Type: resultType,
				},
			},
			stmts,
		)
		funcDecl.Doc = &ast.CommentGroup{List: []*ast.Comment{{
			Text: fmt.Sprintf("// Generate by annotations from %s.%s", instanceFunc.Package, instanceFunc.FuncName),
		}}}
		addDecl(astFile, funcDecl)
		ctx.Methods = append(ctx.Methods, funcDecl)
	}

}
