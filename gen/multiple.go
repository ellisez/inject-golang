package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"os"
	"path/filepath"
	"strings"
)

// gen_constructor.go
func genMultipleFile(moduleInfo *model.ModuleInfo, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenMultipleFilename)

	if moduleInfo.MultipleInstances == nil {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	astFile := &ast.File{
		Name:  astIdent(GenInternalPackage),
		Scope: ast.NewScope(nil),
	}

	genMultipleImportsAst(moduleInfo, astFile)

	genMultipleNewAst(moduleInfo, astFile)

	astFile, err := utils.OptimizeCode(filename, astFile, moduleInfo,
		"// Code generated by \"inject-golang -m multiple\"; DO NOT EDIT.")
	if err != nil {
		return err
	}

	return utils.GenerateCode(filename, astFile, moduleInfo)
}

func genMultipleImportsAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {

	for _, instance := range moduleInfo.MultipleInstances {
		addImport(astFile, moduleInfo, "", instance.Import)
		for _, importInfo := range instance.Imports {
			importName := importInfo.Name
			if importName == "_" {
				importName = ""
			}
			addImport(astFile, moduleInfo, importName, importInfo.Path)
		}
	}
}

// # gen segment: Multiple instance #
func genMultipleNewAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {

	for _, instance := range moduleInfo.MultipleInstances {
		recvVar := utils.FirstToLower(StructName)

		provideInstance := instance.Instance
		if provideInstance == "" || provideInstance == "_" {
			provideInstance = instance.Name
		}

		instanceVar := utils.FirstToLower(provideInstance)
		instanceType := astSelectorExpr(instance.Package, instance.Name)

		stmts := make([]ast.Stmt, 0)
		if instance.PreConstruct != "" {
			// [code] {{Instance}} := {{PreConstruct}}()
			var caller ast.Expr
			if !strings.Contains(instance.PreConstruct, ".") {
				if moduleInfo.HasFunc(instance.PreConstruct) {
					caller = astSelectorExpr(recvVar, instance.PreConstruct)
				} else {
					utils.Failuref("@preConstruct %s, No matching function, must be to specify Package Name, at %s{}", instance.PreConstruct, instance.Name)
				}
			} else {
				caller = utils.TypeToAst(instance.PreConstruct)
			}
			stmts = append(stmts, astDefineStmt(
				astIdent(instanceVar),
				&ast.CallExpr{
					Fun: caller,
				},
			))
		} else {
			// [code] {{Instance}} := &{{Package}}.{{Name}}{}
			stmts = append(stmts, astDefineStmt(
				astIdent(instanceVar),
				astDeclareRef(instanceType, nil),
			))
		}
		for _, field := range instance.Fields {
			fieldName := field.Name
			fieldInstance := field.Instance
			switch field.Source {
			case "ctx":
				if utils.IsFirstLower(fieldName) {
					// [code] {{Instance}}.{{Field.Setter}}(ctx)
					fieldSetter := utils.FieldSetter(field)
					stmts = append(stmts, &ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: astSelectorExpr(instanceVar, fieldSetter),
							Args: []ast.Expr{
								astIdent(recvVar),
							},
						},
					})
				} else {
					// [code] {{Instance}}.{{FieldName}} = ctx
					stmts = append(stmts, astAssignStmt(
						astSelectorExpr(instanceVar, fieldName),
						astIdent(recvVar),
					))
				}
				break
			case "inject":
				injectMode := ""
				if moduleInfo.HasSingleton(fieldInstance) {
					if utils.IsFirstLower(fieldName) {
						// [code] {{Instance}}.{{Field.Setter}}(ctx.{{Field.Instance}}())
						fieldSetter := utils.FieldSetter(field)
						stmts = append(stmts, &ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: astSelectorExpr(instanceVar, fieldSetter),
								Args: []ast.Expr{
									&ast.CallExpr{
										Fun: astSelectorExpr(recvVar, fieldInstance),
									},
								},
							},
						})
					} else {
						// [code] {{Instance}}.{{Field.Name}} = ctx.{{Field.Instance}}()
						stmts = append(stmts, astAssignStmt(
							astSelectorExpr(instanceVar, fieldName),
							&ast.CallExpr{
								Fun: astSelectorExpr(recvVar, fieldInstance),
							},
						))
					}
					injectMode = "singleton"
				}

				if injectMode == "" {
					if moduleInfo.HasWebApp(fieldInstance) {
						if utils.IsFirstLower(fieldName) {
							// [code] {{Instance}}.{{Field.Setter}}(ctx.{{Field.Instance}}())
							fieldSetter := utils.FieldSetter(field)
							stmts = append(stmts, astAssignStmt(
								astSelectorExpr(instanceVar, fieldSetter),
								&ast.CallExpr{
									Fun: astSelectorExpr(recvVar, fieldInstance),
								},
							))
						} else {
							// [code] {{Instance}}.{{Field.Name}} = ctx.{{Field.Instance}}()
							stmts = append(stmts, astAssignStmt(
								astSelectorExpr(instanceVar, fieldName),
								&ast.CallExpr{
									Fun: astSelectorExpr(recvVar, fieldInstance),
								},
							))
						}
						injectMode = "webApp"
					}
				}

				if injectMode == "" {
					if moduleInfo.HasMultiple(fieldInstance) {
						if utils.IsFirstLower(fieldName) {
							// [code] {{Instance}}.{{Field.Setter}}(ctx.New{{Field.Instance}}())
							fieldSetter := utils.FieldSetter(field)
							stmts = append(stmts, astAssignStmt(
								astSelectorExpr(instanceVar, fieldSetter),
								&ast.CallExpr{
									Fun: astSelectorExpr(recvVar, "New"+fieldInstance),
								},
							))
						} else {
							// [code] {{Instance}}.{{Field.Name}} = ctx.New{{Field.Instance}}()
							stmts = append(stmts, astAssignStmt(
								astSelectorExpr(instanceVar, fieldInstance),
								&ast.CallExpr{
									Fun: astSelectorExpr(recvVar, "New"+fieldInstance),
								},
							))
						}
						injectMode = "multiple"
					}
				}

				if injectMode == "" {
					utils.Failuref("%s, \"%s\" No matching Instance, at %s{}", field.Comment, fieldInstance, instance.Name)
				}
				break
			default:

			}
		}

		if instance.PostConstruct != "" {
			// [code] {{PostConstruct}}({{Instance}})
			var caller ast.Expr
			if !strings.Contains(instance.PostConstruct, ".") {
				if moduleInfo.HasFunc(instance.PostConstruct) {
					caller = astSelectorExpr(recvVar, instance.PostConstruct)
				} else {
					utils.Failuref("@postConstruct %s, No matching function, must be to specify Package Name, at %s{}", instance.PreConstruct, instance.Name)
				}
			} else {
				caller = utils.TypeToAst(instance.PostConstruct)
			}
			stmts = append(stmts, &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: caller,
					Args: []ast.Expr{
						astIdent(instanceVar),
					},
				},
			})
		}
		// [code] return {{Instance}}
		stmts = append(stmts, &ast.ReturnStmt{
			Results: []ast.Expr{
				astIdent(instanceVar),
			},
		})

		// [code] func (ctx *Ctx) New{{Instance}}(
		constructor := "New" + provideInstance

		genDoc := &ast.Comment{
			Text: fmt.Sprintf("// Generate by annotations from %s.%s", instance.Package, instance.Name),
		}

		resultType := astStarExpr(instanceType)
		funcDecl := astFuncDecl(
			[]*ast.Field{
				astField(recvVar, astStarExpr(astIdent(StructName))),
			},
			constructor,
			nil,
			[]*ast.Field{
				{
					Type: resultType,
				},
			},
			stmts,
		)
		funcDecl.Doc = &ast.CommentGroup{List: []*ast.Comment{
			{
				Text: fmt.Sprintf("// %s", constructor),
			},
			genDoc,
		}}
		addDecl(astFile, funcDecl)

		/// interface method field
		methodField := astField(
			constructor,
			&ast.FuncType{
				Results: &ast.FieldList{List: []*ast.Field{
					astField("", resultType),
				}},
			},
		)
		methodField.Comment = &ast.CommentGroup{List: []*ast.Comment{
			genDoc,
		}}
		moduleInfo.CtxMethodFields = append(moduleInfo.CtxMethodFields, methodField)
	}

}
