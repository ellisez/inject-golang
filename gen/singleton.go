package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"os"
	"path/filepath"
	"strings"
)

// gen_ctx.go
func genSingletonFile(moduleInfo *model.ModuleInfo, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenSingletonFilename)

	if moduleInfo.SingletonInstances == nil {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	astFile := &ast.File{
		Name:  astIdent(GenInternalPackage),
		Scope: ast.NewScope(nil),
	}

	genSingletonImportsAst(moduleInfo, astFile)

	genSingletonStructAst(moduleInfo, astFile)

	genSingletonNewAst(moduleInfo, astFile)

	astFile, err := utils.OptimizeCode(filename, astFile, moduleInfo,
		"// Code generated by \\\"inject-golang -m singleton\\\"; DO NOT EDIT.")
	if err != nil {
		return err
	}

	return utils.GenerateCode(filename, astFile, moduleInfo)
}

func genSingletonImportsAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {

	for _, instance := range moduleInfo.SingletonInstances {
		addImport(astFile, moduleInfo, "", instance.Import)
		for _, importInfo := range instance.Imports {
			importName := importInfo.Name
			if importName == "_" {
				importName = ""
			}
			addImport(astFile, moduleInfo, importName, importInfo.Path)
		}
	}
	if moduleInfo.WebAppInstances != nil {
		addImport(astFile, moduleInfo, "", "github.com/gofiber/fiber/v2")
	}
}

// # gen segment: Struct #
func genSingletonStructAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {
	fields := make([]*ast.Field, 0)
	funcDecls := make([]*ast.FuncDecl, 0)
	for _, instance := range moduleInfo.SingletonInstances {
		fieldName := instance.PrivateName()
		fieldGetter := instance.Getter()
		fieldSetter := instance.Setter()
		fieldType := astStarExpr(
			astSelectorExpr(
				instance.Package,
				instance.Name,
			),
		)

		/// private field
		field := astField(
			fieldName,
			fieldType,
		)
		fields = append(fields, field)

		getterDecl, getterField := astCtxGetter(
			fmt.Sprintf("// Generate by annotations from %s.%s", instance.Package, instance.Name),
			fieldGetter,
			fieldName,
			fieldType,
		)
		funcDecls = append(funcDecls, getterDecl)
		moduleInfo.CtxMethodFields = append(moduleInfo.CtxMethodFields, getterField)

		setterDecl, setterField := astCtxSetter(
			fmt.Sprintf("// Generate by annotations from %s.%s", instance.Package, instance.Name),
			fieldSetter,
			fieldName,
			fieldType,
		)
		funcDecls = append(funcDecls, setterDecl)
		moduleInfo.CtxMethodFields = append(moduleInfo.CtxMethodFields, setterField)
	}
	if moduleInfo.WebAppInstances != nil {
		for _, instance := range moduleInfo.WebAppInstances {
			fieldName := instance.PrivateName()
			fieldGetter := instance.Getter()
			fieldSetter := instance.Setter()
			fieldType := astStarExpr(
				astSelectorExpr(
					"fiber",
					"App",
				),
			)
			var doc string
			if instance.Package == "" {
				doc = "// Generate by system"
			} else {
				doc = fmt.Sprintf("// Generate by annotations from %s.%s", instance.Package, instance.FuncName)
			}

			/// private field
			field := astField(
				fieldName,
				fieldType,
			)
			fields = append(fields, field)

			getterDecl, getterField := astCtxGetter(
				doc,
				fieldGetter,
				fieldName,
				fieldType,
			)
			funcDecls = append(funcDecls, getterDecl)
			moduleInfo.CtxMethodFields = append(moduleInfo.CtxMethodFields, getterField)

			setterDecl, setterField := astCtxSetter(
				doc,
				fieldSetter,
				fieldName,
				fieldType,
			)
			funcDecls = append(funcDecls, setterDecl)
			moduleInfo.CtxMethodFields = append(moduleInfo.CtxMethodFields, setterField)
		}
	}

	structDecl := astStructDecl(
		StructName,
		fields,
	)

	addDecl(astFile, structDecl)

	for _, funcDecl := range funcDecls {
		addDecl(astFile, funcDecl)
	}
}

// # gen segment: Singleton instance #
func genSingletonNewAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {
	varName := "ctx"
	stmts := make([]ast.Stmt, 0)
	// [code] ctx := &Ctx{}
	stmts = append(stmts, astDefineStmt(
		astIdent(varName),
		astDeclareRef(astIdent(StructName), nil),
	))

	assignStmts := make([]ast.Stmt, 0)
	postStmts := make([]ast.Stmt, 0)
	for _, instance := range moduleInfo.SingletonInstances {
		privateName := instance.PrivateName()
		structFieldAst := astSelectorExpr(varName, privateName)

		if instance.PreConstruct != "" {
			// [code] ctx.{{PrivateName}} = {{PreConstruct}}()
			var caller ast.Expr
			if !strings.Contains(instance.PreConstruct, ".") {
				if moduleInfo.HasFunc(instance.PreConstruct) {
					caller = astSelectorExpr(varName, instance.PreConstruct)
				} else {
					utils.Failuref("@preConstruct %s, No matching function, try to specify Package Name, at %s{}", instance.PreConstruct, instance.Name)
				}
			} else {
				caller = utils.TypeToAst(instance.PreConstruct)
			}
			stmt := astAssignStmt(
				structFieldAst,
				&ast.CallExpr{
					Fun: caller,
				},
			)
			stmts = append(stmts, stmt)
		} else {
			// [code] ctx.{{PrivateName}} = &{{Package}}.{{Name}}{}
			stmts = append(stmts, astAssignStmt(
				structFieldAst,
				astDeclareRef(
					astSelectorExpr(
						instance.Package,
						instance.Name,
					),
					nil,
				),
			))
		}

		for _, field := range instance.Fields {
			fieldName := field.Name
			fieldInstance := field.Instance
			switch field.Source {
			case "ctx":
				// [code] ctx.{{PrivateName}}.{{Field.Name}} = ctx
				assignStmts = append(assignStmts, astAssignStmt(
					astSelectorExprRecur(structFieldAst, fieldName),
					astIdent(varName),
				))
				break
			case "inject":
				injectMode := ""
				if moduleInfo.HasSingleton(fieldInstance) {
					if utils.IsFirstLower(fieldName) {
						// [code] ctx.{{PrivateName}}.{{Field.Setter}}(ctx.{{Field.Instance}}())
						fieldSetter := utils.FieldSetter(field)
						assignStmts = append(assignStmts, &ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: astSelectorExprRecur(structFieldAst, fieldSetter),
								Args: []ast.Expr{
									&ast.CallExpr{
										Fun: astSelectorExpr(varName, fieldInstance),
									},
								},
							},
						})
					} else {
						// [code] ctx.{{PrivateName}}.{{Field.Name}} = ctx.{{Field.Instance}}()
						assignStmts = append(assignStmts, astAssignStmt(
							astSelectorExprRecur(structFieldAst, fieldName),
							&ast.CallExpr{
								Fun: astSelectorExpr(varName, fieldInstance),
							},
						))
					}
					injectMode = "singleton"
				}

				if injectMode == "" {
					if moduleInfo.HasWebApp(fieldInstance) {
						if utils.IsFirstLower(fieldName) {
							// [code] ctx.{{PrivateName}}.{{Field.Setter}}(ctx.{{Field.Instance}}())
							fieldSetter := utils.FieldSetter(field)
							assignStmts = append(assignStmts, astAssignStmt(
								astSelectorExprRecur(structFieldAst, fieldSetter),
								&ast.CallExpr{
									Fun: astSelectorExpr(varName, fieldInstance),
								},
							))
						} else {
							// [code] ctx.{{PrivateName}}.{{Field.Name}} = ctx.{{Field.Instance}}()
							assignStmts = append(assignStmts, astAssignStmt(
								astSelectorExprRecur(structFieldAst, fieldName),
								&ast.CallExpr{
									Fun: astSelectorExpr(varName, fieldInstance),
								},
							))
						}
						injectMode = "webApp"
					}
				}

				if injectMode == "" {
					if moduleInfo.HasMultiple(fieldInstance) {
						if utils.IsFirstLower(fieldName) {
							// [code] {{PrivateName}}.{{Field.Setter}}(ctx.New{{Field.Instance}}())
							fieldSetter := utils.FieldSetter(field)
							assignStmts = append(assignStmts, astAssignStmt(
								astSelectorExprRecur(structFieldAst, fieldSetter),
								&ast.CallExpr{
									Fun: astSelectorExpr(varName, "New"+fieldInstance),
								},
							))
						} else {
							// [code] {{PrivateName}}.{{Field.Name}} = ctx.New{{Field.Instance}}()
							assignStmts = append(assignStmts, astAssignStmt(
								astSelectorExprRecur(structFieldAst, fieldInstance),
								&ast.CallExpr{
									Fun: astSelectorExpr(varName, "New"+fieldInstance),
								},
							))
						}
						injectMode = "multiple"
					}
				}

				if injectMode == "" {
					utils.Failuref("%s, \"%s\" No matching Instance, at %s{}", field.Comment, fieldInstance, instance.Name)
				}
				break
			default:

			}
		}

		if instance.PostConstruct != "" {
			// [code] {{PostConstruct}}(ctx.{{Instance}})
			var caller ast.Expr
			if !strings.Contains(instance.PostConstruct, ".") {
				if moduleInfo.HasFunc(instance.PostConstruct) {
					caller = astSelectorExpr(varName, instance.PostConstruct)
				} else {
					utils.Failuref("@postConstruct %s, No matching function, try to specify Package Name, at %s{}", instance.PreConstruct, instance.Name)
				}
			} else {
				caller = utils.TypeToAst(instance.PostConstruct)
			}
			postStmts = append(postStmts, &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: caller,
					Args: []ast.Expr{
						structFieldAst,
					},
				},
			})
		}
	}

	for _, instance := range moduleInfo.WebAppInstances {
		// [code] ctx.{{WebApp}} = fiber.New()
		stmts = append(stmts, astAssignStmt(
			astSelectorExpr(varName, utils.FirstToLower(instance.WebApp)),
			&ast.CallExpr{
				Fun: astSelectorExpr(
					"fiber",
					"New",
				),
			},
		))
	}

	stmts = append(stmts, assignStmts...)
	stmts = append(stmts, postStmts...)
	// [code] return ctx
	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{
			astIdent(varName),
		},
	})

	funcDecl := astFuncDecl(
		nil,
		"New",
		nil,
		[]*ast.Field{
			{
				Type: astStarExpr(astIdent(StructName)),
			},
		},
		stmts,
	)

	addDecl(astFile, funcDecl)
}
