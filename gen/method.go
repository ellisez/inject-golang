package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"path/filepath"
)

// gen_method.go
func genMethodFile(moduleInfo *model.ModuleInfo, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenMethodFilename)

	if len(moduleInfo.MethodInstances) == 0 {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	err := utils.CreateDirectoryIfNotExists(fileDir)
	if err != nil {
		return err
	}

	file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer file.Close()

	astFile := &ast.File{
		Name:  astIdent(GenPackage),
		Scope: ast.NewScope(nil),
	}

	genMethodImportsAst(moduleInfo, astFile)

	genMethodAst(moduleInfo, astFile)

	addFileDoc(astFile, "// Code generated by \"inject-golang -m func\"; DO NOT EDIT.")

	err = format.Node(file, token.NewFileSet(), astFile)
	if err != nil {
		return err
	}
	return nil
}

func genMethodImportsAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {

	for _, instance := range moduleInfo.MethodInstances {
		uniqueImport(astFile, "", instance.Import)
		for _, importInfo := range instance.Imports {
			importName := importInfo.Name
			if importName == "_" {
				importName = ""
			}
			uniqueImport(astFile, importName, importInfo.Path)
			uniqueCtxImport(moduleInfo, importName, importInfo.Path)
		}
	}
	addImportDecl(astFile)
}

// # gen segment: Method inject #
func genMethodAst(moduleInfo *model.ModuleInfo, astFile *ast.File) {
	recvVar := utils.FirstToLower(StructName)

	for _, instance := range moduleInfo.MethodInstances {
		params := make([]*ast.Field, 0)
		if instance.Recv.Source == "" {
			params = append(params,
				astField(instance.Recv.Instance, utils.AccessType(
					instance.Recv.Type,
					instance.Package,
					GenPackage,
				),
				),
			)
		}
		for _, paramInfo := range instance.Params {
			if paramInfo.Source == "" {
				// [code] {{ParamInstance}} {{ParamType}},
				paramInstance := paramInfo.Instance
				params = append(params,
					astField(paramInstance,
						utils.AccessType(
							paramInfo.Type,
							instance.Package,
							GenPackage,
						),
					),
				)
			}
		}

		stmts := make([]ast.Stmt, 0)
		args := make([]ast.Expr, 0)
		for _, paramInfo := range instance.Params {
			paramInstance := paramInfo.Instance

			switch paramInfo.Source {
			case "ctx":
				// [code] ctx,
				args = append(args, astIdent(recvVar))
				break
			case "inject":
				injectMode := ""
				if moduleInfo.HasSingleton(paramInstance) {
					// [code] ctx.{{ParamInstance}}(),
					args = append(args,
						&ast.CallExpr{
							Fun: astSelectorExpr(recvVar, paramInstance),
						})
					injectMode = "singleton"
				}

				if injectMode == "" {
					if moduleInfo.HasWebApp(paramInstance) {
						// [code] ctx.{{ParamInstance}}(),
						args = append(args,
							&ast.CallExpr{
								Fun: astSelectorExpr(recvVar, paramInstance),
							})
						injectMode = "webApp"
					}
				}

				if injectMode == "" {
					if moduleInfo.HasMultiple(paramInstance) {
						// [code] ctx.New{{ParamInstance}}(),
						args = append(args, &ast.CallExpr{
							Fun: astSelectorExpr(recvVar, "New"+paramInstance),
						})
						injectMode = "multiple"
					}
				}

				if injectMode == "" {
					utils.Failuref("%s, \"%s\" No matching Instance, at %s()", paramInfo.Comment, paramInstance, instance.FuncName)
				}
				break
			default:
				// [code] {{ParamInstance}},
				args = append(args, astIdent(paramInstance))
			}
		}
		var fun ast.Expr
		if instance.Recv.Source == "inject" {
			fun = astSelectorExprRecur(
				astSelectorExpr("ctx", instance.Recv.Instance),
				instance.FuncName,
			)
		} else {
			fun = astSelectorExpr(instance.Recv.Instance, instance.FuncName)
		}
		if len(instance.Results) == 0 {
			stmts = append(stmts, &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun:  fun,
					Args: args,
				},
			})
		} else {
			stmts = append(stmts, &ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.CallExpr{
						Fun:  fun,
						Args: args,
					},
				},
			})
		}

		results := make([]*ast.Field, 0)
		for _, result := range instance.Results {
			results = append(results, astField(result.Name, result.Type))
		}

		funcDecl := astFuncDecl(
			[]*ast.Field{
				astField(recvVar, astStarExpr(astIdent(StructName))),
			},
			instance.Proxy,
			params,
			results,
			stmts,
		)
		genDoc := &ast.Comment{
			Text: fmt.Sprintf("// Generate by annotations from %s.%s", instance.Package, instance.FuncName),
		}
		funcDecl.Doc = &ast.CommentGroup{List: []*ast.Comment{
			genDoc,
		}}
		addDecl(astFile, funcDecl)

		/// interface method field
		methodField := astField(
			instance.Proxy,
			&ast.FuncType{
				Params:  &ast.FieldList{List: params},
				Results: &ast.FieldList{List: results},
			},
		)
		methodField.Comment = &ast.CommentGroup{List: []*ast.Comment{
			genDoc,
		}}
		moduleInfo.CtxMethodFields = append(moduleInfo.CtxMethodFields, methodField)
	}

}
