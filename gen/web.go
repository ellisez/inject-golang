package gen

import (
	"fmt"
	. "github.com/ellisez/inject-golang/global"
	"github.com/ellisez/inject-golang/model"
	"github.com/ellisez/inject-golang/utils"
	"go/ast"
	"go/token"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strconv"
)

func genWebFile(ctx *model.Ctx, dir string) error {
	fileDir := filepath.Join(dir, GenInternalPackage)
	filename := filepath.Join(fileDir, GenWebFilename)

	if ctx.SingletonInstance.WebLen() == 0 {
		err := os.Remove(filename)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}
		return nil
	}

	astFile := &ast.File{
		Name:  ast.NewIdent(GenInternalPackage),
		Scope: ast.NewScope(nil),
	}

	genWebImportsAst(ctx, astFile, filename)

	genWebAppStartupAst(ctx, astFile)

	genMiddlewareAst(ctx, astFile)

	genRouterAst(ctx, astFile)

	return utils.GenerateCode(filename, astFile, ctx,
		`// Code generated by "inject-golang -m web"; DO NOT EDIT.`)
}

func genWebImportsAst(ctx *model.Ctx, astFile *ast.File, filename string) {
	err := addImport(astFile, ctx, "", "fmt")
	if err != nil {
		utils.Failuref("%s, %s", filename, err.Error())
	}
	err = addImport(astFile, ctx, "", "github.com/gofiber/fiber/v2")
	if err != nil {
		utils.Failuref("%s, %s", filename, err.Error())
	}
	err = addImport(astFile, ctx, "", path.Join(Mod.Package, GenPackage, "utils"))
	if err != nil {
		utils.Failuref("%s, %s", filename, err.Error())
	}

	for i := 0; i < ctx.SingletonInstance.Len(); i++ {
		instance, webApplication := ctx.SingletonInstance.IndexOf(i)
		if webApplication != nil {
			sort.Sort(webApplication)

			for _, importInfo := range instance.Imports {
				importName := importInfo.Alias
				if importName == "_" {
					importName = ""
				}
				err := addImport(astFile, ctx, importName, importInfo.Path)
				if err != nil {
					utils.Failuref("%s, %s", filename, err.Error())
				}
			}

			for j := 0; j < webApplication.Len(); j++ {
				key := webApplication.IndexOf(j)
				var imports []*model.Import
				switch key.Type {
				case "middleware":
					imports = webApplication.GetMiddleware(key.Instance).Imports
				case "router":
					imports = webApplication.GetRouter(key.Instance).Imports
				}
				for _, importInfo := range imports {
					importName := importInfo.Alias
					if importName == "_" {
						importName = ""
					}
					err := addImport(astFile, ctx, importName, importInfo.Path)
					if err != nil {
						utils.Failuref("%s, %s", filename, err.Error())
					}
				}
			}
		}

	}
}

func errorReturnStmts() *ast.IfStmt {
	return &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			Op: token.NEQ,
			X:  ast.NewIdent("err"),
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{ast.NewIdent("err")},
				},
			},
		},
	}
}
func genWebAppStartupAst(ctx *model.Ctx, astFile *ast.File) {
	ctxVar := utils.FirstToLower(CtxType)

	stmtOfMiddleware := func(middleware *model.Middleware, webExpr ast.Expr, stmts []ast.Stmt) []ast.Stmt {
		// [code] ctx.{{instance}}.Group({{Path}}, {{Proxy}})
		stmts = append(stmts, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: astSelectorExprRecur(
					webExpr,
					"Group",
				),
				Args: []ast.Expr{
					astStringExpr(middleware.Path),
					astSelectorExpr(ctxVar, middleware.FuncName),
				},
			},
		})
		return stmts
	}

	stmtOfRouter := func(router *model.Router, webExpr ast.Expr, stmts []ast.Stmt) []ast.Stmt {
		for _, method := range router.Methods {
			// [code] ctx.{{instance}}.{{Method}}({{Path}}, {{Proxy}})
			stmts = append(stmts, &ast.ExprStmt{
				X: &ast.CallExpr{
					Fun: astSelectorExprRecur(
						webExpr,
						method,
					),
					Args: []ast.Expr{
						astStringExpr(router.Path),
						astSelectorExpr(ctxVar, router.FuncName),
					},
				},
			})
		}
		return stmts
	}

	stmtOfResource := func(resource *model.WebResource, webExpr ast.Expr, stmts []ast.Stmt) []ast.Stmt {
		// [code] ctx.{{instance}}.Static({{Path}}, {{Path}}, {{...}})
		args := []ast.Expr{
			astStringExpr(resource.Path),
			astStringExpr(resource.Dirname),
		}
		if len(resource.Features) > 0 ||
			resource.Index != "" ||
			resource.MaxAge != 0 {
			var eltExpr []ast.Expr
			for _, feature := range resource.Features {
				eltExpr = append(eltExpr, &ast.KeyValueExpr{
					Key:   ast.NewIdent(feature),
					Value: ast.NewIdent("true"),
				})
			}
			if resource.Index != "" {
				eltExpr = append(eltExpr, &ast.KeyValueExpr{
					Key:   ast.NewIdent("Index"),
					Value: astStringExpr(resource.Index),
				})
			}
			if resource.MaxAge != 0 {
				eltExpr = append(eltExpr, &ast.KeyValueExpr{
					Key:   ast.NewIdent("MaxAge"),
					Value: astIntExpr(strconv.Itoa(resource.MaxAge)),
				})
			}
			args = append(args, astDeclareExpr(
				astSelectorExpr("fiber", "Static"),
				eltExpr,
			))
		}

		stmts = append(stmts, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: astSelectorExprRecur(
					webExpr,
					"Static",
				),
				Args: args,
			},
		})
		return stmts
	}

	for i := 0; i < ctx.SingletonInstance.Len(); i++ {
		instance, webApplication := ctx.SingletonInstance.IndexOf(i)
		if webApplication != nil {
			instanceName := instance.Instance
			instanceFunc := instance.Func
			instanceVar := utils.FirstToLower(instanceName)

			webExpr := astSelectorExpr(ctxVar, instanceVar)

			var proxyParams []*ast.Field
			if instanceFunc.FuncName == "" {
				if webApplication.IsTls {
					// [code] addr string, certFile string, keyFile string,
					proxyParams = []*ast.Field{
						astField("addr", ast.NewIdent("string")),
						astField("certFile", ast.NewIdent("string")),
						astField("keyFile", ast.NewIdent("string")),
					}
				} else {
					// [code] addr string,
					proxyParams = []*ast.Field{
						astField("addr", ast.NewIdent("string")),
					}
				}
			} else {
				// [code] {{ParamInstance}} {{ParamType}},
				proxyParams = astInstanceProxyParams(instance.Func)
			}

			var stmts []ast.Stmt

			for j := 0; j < webApplication.Len(); j++ {
				key := webApplication.IndexOf(j)
				switch key.Type {
				case "middleware":
					middleware := webApplication.GetMiddleware(key.Instance)
					stmts = stmtOfMiddleware(middleware, webExpr, stmts)
				case "router":
					router := webApplication.GetRouter(key.Instance)
					stmts = stmtOfRouter(router, webExpr, stmts)
				case "resource":
					resource := webApplication.GetResource(key.Instance)
					stmts = stmtOfResource(resource, webExpr, stmts)
				}
			}

			if instance.FuncName != "" {
				instanceCallExpr, varDefineStmts := astInstanceCallExpr(astSelectorExpr(instance.Package, instance.FuncName), instance.Func, ctx, ctxVar)
				if varDefineStmts != nil {
					stmts = append(stmts, varDefineStmts...)
				}

				if webApplication.IsTls {
					// [code] addr, certFile, keyFile, err := {{Package}}.{{FuncName}}(...)
					stmts = append(stmts, astDefineStmtMany(
						[]ast.Expr{
							ast.NewIdent("addr"),
							ast.NewIdent("certFile"),
							ast.NewIdent("keyFile"),
							ast.NewIdent("err"),
						},
						instanceCallExpr,
					))
				} else {
					// [code] addr, err := {{Package}}.{{FuncName}}(...)
					stmts = append(stmts, astDefineStmtMany(
						[]ast.Expr{
							ast.NewIdent("addr"),
							ast.NewIdent("err"),
						},
						instanceCallExpr,
					))
				}

				stmts = append(stmts, errorReturnStmts())
			}

			if webApplication.IsTls {
				stmts = append(stmts, &ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: astSelectorExprRecur(
								&ast.CallExpr{
									Fun: astSelectorExpr(ctxVar, instanceName),
								},
								"ListenTLS",
							),
							Args: []ast.Expr{
								ast.NewIdent("addr"),
								ast.NewIdent("certFile"),
								ast.NewIdent("keyFile"),
							},
						},
					},
				})
			} else {
				stmts = append(stmts, &ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: astSelectorExprRecur(
								&ast.CallExpr{
									Fun: astSelectorExpr(ctxVar, instanceName),
								},
								"Listen",
							),
							Args: []ast.Expr{
								ast.NewIdent("addr"),
							},
						},
					},
				})
			}

			doc := "// Generate by system"
			if instanceFunc.FuncName != "" {
				doc = fmt.Sprintf("// Generate by annotations from %s.%s", ImportAliasMap[instanceFunc.Package].Path, instanceFunc.FuncName)
			}

			proxyFuncDecl := astFuncDecl(
				[]*ast.Field{
					astField(ctxVar, astStarExpr(ast.NewIdent(CtxType))),
				},
				instanceName+"Startup",
				proxyParams,
				[]*ast.Field{
					astField("", ast.NewIdent("error")),
				},
				stmts,
			)
			proxyFuncDecl.Doc = &ast.CommentGroup{List: []*ast.Comment{{
				Text: doc,
			}}}
			addDecl(astFile, proxyFuncDecl)
			ctx.Methods[proxyFuncDecl.Name.String()] = proxyFuncDecl
		}
	}

}

func defineParamStmt(convFunc string, param *model.Field) ast.Stmt {
	paramVar := utils.FirstToLower(param.Instance)
	return astDefineStmt(
		ast.NewIdent(paramVar),
		&ast.CallExpr{
			Fun: astSelectorExpr("utils", convFunc),
			Args: []ast.Expr{
				ast.NewIdent("webCtx"),
				astStringExpr(paramVar),
			},
		},
	)
}

func defineParamWithError(convFunc string, param *model.Field) []ast.Stmt {
	paramVar := utils.FirstToLower(param.Instance)
	return []ast.Stmt{
		astDefineStmtMany(
			[]ast.Expr{
				ast.NewIdent(paramVar),
				ast.NewIdent("err"),
			},
			&ast.CallExpr{
				Fun: astSelectorExpr("utils", convFunc),
				Args: []ast.Expr{
					ast.NewIdent("webCtx"),
					astStringExpr(paramVar),
				},
			},
		),
		errorReturnStmts(),
	}
}

func defineParamByParser(convFunc string, param *model.Field, packageName string) []ast.Stmt {
	paramVar := utils.FirstToLower(param.Instance)
	switch bodyType := param.Type.(type) {
	case *ast.ArrayType:
		return []ast.Stmt{
			// [code] {{ParamInstance}} := []{{Package}}.{{ParamType}}{}
			astDefineStmt(
				ast.NewIdent(paramVar),
				astDeclareExpr(
					bodyType,
					nil,
				),
			),
			// [code] err := utils.{{ParamSource}}Parser(webCtx, &{{ParamInstance}})
			astAssignStmt(
				ast.NewIdent("err"),
				&ast.CallExpr{
					Fun: astSelectorExpr("utils", convFunc),
					Args: []ast.Expr{
						ast.NewIdent("webCtx"),
						&ast.UnaryExpr{
							Op: token.AND,
							X:  ast.NewIdent(paramVar),
						},
					},
				},
			),
			errorReturnStmts(),
		}
	case *ast.StarExpr:
		return []ast.Stmt{
			// [code] {{ParamInstance}} := &{{Package}}.{{ParamType}}{}
			astDefineStmt(
				ast.NewIdent(paramVar),
				astDeclareRef(
					bodyType.X,
					nil,
				),
			),
			// [code] err := utils.{{ParamSource}}Parser(webCtx, {{ParamInstance}})
			astAssignStmt(
				ast.NewIdent("err"),
				&ast.CallExpr{
					Fun: astSelectorExpr("utils", convFunc),
					Args: []ast.Expr{
						ast.NewIdent("webCtx"),
						ast.NewIdent(paramVar),
					},
				},
			),
			errorReturnStmts(),
		}
	default:
		return []ast.Stmt{
			// [code] {{ParamInstance}} := &{{Package}}.{{ParamType}}{}
			astDefineStmt(
				ast.NewIdent(paramVar),
				astDeclareRef(
					bodyType,
					nil,
				),
			),
			// [code] err := utils.{{ParamSource}}Parser(webCtx, {{ParamInstance}})
			astAssignStmt(
				ast.NewIdent("err"),
				&ast.CallExpr{
					Fun: astSelectorExpr("utils", convFunc),
					Args: []ast.Expr{
						ast.NewIdent("webCtx"),
						ast.NewIdent(paramVar),
					},
				},
			),
			errorReturnStmts(),
		}
	}
}
func genWebBodyParam(bodyParam *model.Field, packageName string, funcNode *model.Func) []ast.Stmt {
	if bodyParam != nil {
		bodyAstType := bodyParam.Type
		paramVar := utils.FirstToLower(bodyParam.Instance)
		switch bodyType := bodyAstType.(type) {
		case *ast.ArrayType:
			elt, ok := bodyType.Elt.(*ast.Ident)
			if ok && elt.String() == "byte" {
				return []ast.Stmt{
					astDefineStmt(
						ast.NewIdent(paramVar),
						&ast.CallExpr{
							Fun: astSelectorExpr("utils", "Body"),
							Args: []ast.Expr{
								ast.NewIdent("webCtx"),
							},
						},
					),
				}
			}
		case *ast.Ident:
			typeIdent := bodyType.String()
			if typeIdent == "string" {
				return []ast.Stmt{
					astDefineStmt(
						ast.NewIdent(paramVar),
						&ast.CallExpr{
							Fun: astSelectorExpr("utils", "BodyString"),
							Args: []ast.Expr{
								ast.NewIdent("webCtx"),
							},
						},
					),
				}
			} else if utils.IsFirstLower(typeIdent) {
				utils.Failuref("%s %s, unsupport type %s", funcNode.Loc.String(), bodyParam.Comment, utils.TypeToString(bodyAstType))
			}
		}
		return defineParamByParser("BodyParser", bodyParam, packageName)
	}
	return nil
}

func genWebHeaderParams(headerParams []*model.Field, packageName string, funcNode *model.Func) []ast.Stmt {
	if len(headerParams) > 0 {
		stmts := make([]ast.Stmt, 0)
		for _, param := range headerParams {
			paramType := param.Type
			switch caseType := paramType.(type) {
			case *ast.Ident:
				typeStr := caseType.String()
				switch typeStr {
				case "string":
					stmts = append(stmts, defineParamStmt("Header", param))
					continue
				case "int":
					stmts = append(stmts, defineParamWithError("HeaderInt", param)...)
					continue
				case "bool":
					stmts = append(stmts, defineParamWithError("HeaderBool", param)...)
					continue
				case "float64":
					stmts = append(stmts, defineParamWithError("HeaderFloat", param)...)
					continue
				default:
					if utils.IsFirstLower(typeStr) {
						utils.Failuref("%s %s, unsupport type %s", funcNode.Loc.String(), param.Comment, utils.TypeToString(paramType))
					}
				}
			}
			stmts = append(stmts, defineParamByParser("HeaderParser", param, packageName)...)
		}
		return stmts
	}
	return nil
}
func genWebQueryParams(queryParams []*model.Field, packageName string, funcNode *model.Func) []ast.Stmt {
	if len(queryParams) > 0 {
		stmts := make([]ast.Stmt, 0)
		for _, param := range queryParams {
			paramType := param.Type
			switch caseType := paramType.(type) {
			case *ast.Ident:
				typeStr := caseType.String()
				switch typeStr {
				case "string":
					stmts = append(stmts, defineParamStmt("Query", param))
					continue
				case "int":
					stmts = append(stmts, defineParamWithError("QueryInt", param)...)
					continue
				case "bool":
					stmts = append(stmts, defineParamWithError("QueryBool", param)...)
					continue
				case "float64":
					stmts = append(stmts, defineParamWithError("QueryFloat", param)...)
					continue
				default:
					if utils.IsFirstLower(typeStr) {
						utils.Failuref("%s %s, unsupport type %s", funcNode.Loc.String(), param.Comment, utils.TypeToString(paramType))
					}
				}
			}
			stmts = append(stmts, defineParamByParser("QueryParser", param, packageName)...)
		}
		return stmts
	}
	return nil
}

func genWebPathParams(pathParams []*model.Field, packageName string, funcNode *model.Func) []ast.Stmt {
	if len(pathParams) > 0 {
		stmts := make([]ast.Stmt, 0)
		for _, param := range pathParams {
			paramType := param.Type
			switch paramType.(type) {
			case *ast.Ident:
				typeStr := paramType.(*ast.Ident).String()
				switch typeStr {
				case "string":
					stmts = append(stmts, defineParamStmt("Params", param))
					continue
				case "int":
					stmts = append(stmts, defineParamWithError("ParamsInt", param)...)
					continue
				case "bool":
					stmts = append(stmts, defineParamWithError("ParamsBool", param)...)
					continue
				case "float64":
					stmts = append(stmts, defineParamWithError("ParamsFloat", param)...)
					continue
				default:
					if utils.IsFirstLower(typeStr) {
						utils.Failuref("%s %s, unsupport type %s", funcNode.Loc.String(), param.Comment, utils.TypeToString(paramType))
					}
				}
			}
			stmts = append(stmts, defineParamByParser("ParamsParser", param, packageName)...)
		}
		return stmts
	}
	return nil
}
func genWebFormParams(formParams []*model.Field, packageName string, funcNode *model.Func) []ast.Stmt {
	if len(formParams) > 0 {
		stmts := make([]ast.Stmt, 0)
		for _, param := range formParams {
			paramType := param.Type
			switch caseType := paramType.(type) {
			case *ast.Ident:
				typeStr := caseType.String()
				switch typeStr {
				case "string":
					stmts = append(stmts, defineParamStmt("FormString", param))
					continue
				case "int":
					stmts = append(stmts, defineParamWithError("FormInt", param)...)
					continue
				case "bool":
					stmts = append(stmts, defineParamWithError("FormBool", param)...)
					continue
				case "float64":
					stmts = append(stmts, defineParamWithError("FormFloat", param)...)
					continue
				default:
					if utils.IsFirstLower(typeStr) {
						utils.Failuref("%s %s, unsupport type %s", funcNode.Loc.String(), param.Comment, utils.TypeToString(paramType))
					}
				}
			case *ast.StarExpr:
				// [code] *multipart.FileHeader
				starX := paramType.(*ast.StarExpr).X
				selectorExpr, ok := starX.(*ast.SelectorExpr)
				if ok {
					selectorX, ok := selectorExpr.X.(*ast.Ident)
					if ok {
						if selectorX.String() == "multipart" && selectorExpr.Sel.String() == "FileHeader" {
							stmts = append(stmts, defineParamStmt("FormFile", param))
							continue
						}
					}
				}
			}
			stmts = append(stmts, defineParamByParser("FormParser", param, packageName)...)
		}
		return stmts
	}
	return nil
}
